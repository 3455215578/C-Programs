#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;

/** 前向声明 **/
typedef struct node
{
	ElemType data;
	struct node* next; // 在结构体定义被完成之前，编译器不知道 Node 是一个类型别名
}Node;

Node* Create_HeadNode(void)
{
	// 定义头节点
	//  data: 0;
	//  next: NULL
	Node* head = (Node*)malloc(sizeof(Node));

	head->data = 0;

	head->next = NULL;

	return head;
}

/**

	+―――――――――――+    +―――――――――――――――――+	 +――――――――――――――――+
	| 0 | node1 |    | element | node2 |	 | element | next |
	+―――――――――――+    +―――――――――――――――――+	 +――――――――――――――――+
		head              node1		              node2

**/


/** 遍历链表 **/
/** 哑节点：添加在链表头部，不存储数据的节点 **/
/** 在包含哑节点的链表中，"头节点"指的是这个哑节点本身，而"第一个节点"则是指哑节点之后的第一个实际数据节点。 **/
void Travel_List(Node* list)
{
	// 让node指向node1
	Node* node = list->next;

	while (node != NULL)
	{
		printf("%d\n", node->data);

		// 更新node
		node = node->next; // 因为node1的指针域指向node2, 所以让node指向node1的指针域, 即node指向node2
	}

	printf("\n");
}

/**

// 原来的头节点
				+――――――――――+
	head     :  | 0 | NULL |
				+――――――――――+


// 1.创建新节点，并给数据域赋值
				+――――――――――――――――+
	new_node : 	| element |      |
				+――――――――――――――――+


// 2.将原来头节点的指针域赋值给新节点的指针域
				+――――――――――+
	head     :  | 0 | NULL |
				+――――――――――+

				+――――――――――――――――+
	new_node : 	| element | NULL |
				+――――――――――――――――+

// 3.将原来头节点的指针域指向新节点
				+――――――――――――――+
	head     :  | 0 | new_node |
				+――――――――――――――+

				+――――――――――――――――+
	new_node : 	| element | NULL |
				+――――――――――――――――+

**/


/** 插入节点 -- 1.头插法 **/
/** 每次都在头节点之后插入新节点 **/
void Insert_Head(Node* list, ElemType element)
{
	// 1.在堆内存中创建新节点，并给它的数据域赋值            
	Node* new_node = (Node*)malloc(sizeof(Node));        
	new_node->data = element; 

	// 2.把头节点的指针域赋值给新节点
	new_node->next = list->next;

	// 3.让头节点指向新节点
	list->next = new_node;
}

/** 获取尾节点 **/
Node* Get_TailNode(Node* list)
{
	Node* node = list;

	while (node->next != NULL)
	{
		node = node->next;
	}

	return node;
}

/** 插入节点 -- 2.尾插法 **/
/** 把新节点作为新的尾节点 **/
void Insert_Tail(Node* list, ElemType element)
{

	// 每次都要获取链表的尾节点
	Node* tail_node = Get_TailNode(list);

	// 1.在堆内存中创建新节点，并给它的数据域赋值            
	Node* new_node = (Node*)malloc(sizeof(Node));
	new_node->data = element;

	// 2.把尾节点的指针域赋值给新节点
	new_node->next = tail_node->next;

	// 3.把尾节点的指针域赋值给新节点
	tail_node->next = new_node;

}

/**
			+―――――――――――+    +―――――――――――――――――+	 +――――――――――――――――+	     +――――――――――――――――+
			| 0 | node1 |    | element | node2 |	 | element | next |	     | element | next |
			+―――――――――――+    +―――――――――――――――――+	 +――――――――――――――――+	     +――――――――――――――――+
				head                node1		           node2		            node3
 pos       头节点不存储数据            1                      2	                      3
**/

/** 在指定位置插入节点 **/
void Insert_Node(Node* list, int pos, ElemType element)
{
	// 1.先找到插入位置之前的节点
	Node* node = list;

	for (int i = 0; i < pos - 1; i++) // pos=2
	{
		if (node->next == NULL)
		{
			return;
		}

		node = node->next;
	}

	// 2.创建新节点
	Node* new_node = (Node*)malloc(sizeof(Node));
	new_node->data = element;

	// 3.让新节点与插入位置之前的节点原来所指向的节点相连
	new_node->next = node->next;

	// 4.让插入位置之前的节点与新节点相连
	node->next = new_node;
}


int main(void)
{
	// 初始化链表(此刻只有头节点)
	Node* list = Create_HeadNode();

	Insert_Tail(list, 10);
	Insert_Tail(list, 20);
	Insert_Tail(list, 30);

	Travel_List(list);

	Insert_Node(list, 1, 23);

	printf("\n");
	Travel_List(list);

	return 0;
}